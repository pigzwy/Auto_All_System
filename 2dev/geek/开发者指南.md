# P工具箱 (GeekezBrowser) 开发者指南

本文档面向开发/维护 `P工具箱` 的同学，说明当前 Geek 版（基于 GeekezBrowser）的架构、依赖、可复用模块，以及如何新增一个“专区”（例如 GB 专区 / GPT 专区）。

目标：
- 现在以“先堆功能”为主：新任务优先加在 `2dev/geek/geek_process.py`；GUI 只做按钮 + `task_type` 分发。
- 同时把边界和复用点记录清楚，后续拆分/扩展成本低。

相关规划文档：`P工具箱_拆分规划.md`

---

## 1. 快速入口

### 1.1 当前主 GUI（P工具箱）

- 入口：`2dev/geek/geek_main_gui.py`
- 启动：

```bash
python 2dev/geek/geek_main_gui.py
```

### 1.2 旧 Geek GUI（较简版）

- 入口：`2dev/geek/geek_gui.py`
- 它也会被主 GUI（老 BitBrowser GUI）通过按钮打开：`create_window_gui.py` 的 `action_open_geek_gui()`

---

## 2. 运行时架构（调用链）

文字版架构图：

```text
GUI: 2dev/geek/geek_main_gui.py
  └─ GeekWorkerThread (后台线程 + 并发 + 日志捕获)
      └─ GeekProcess: 2dev/geek/geek_process.py (流程编排)
          ├─ GeekezBrowserAPI: 2dev/geek/geek_browser_api.py
          │   ├─ 控制端口 HTTP: /health /profiles/{id}/launch /profiles/{id}/close /shutdown
          │   └─ 本地 profile 文件: profiles.json / settings.json
          └─ 复用原仓库业务模块（Playwright 页面逻辑/状态落库/导出）
              ├─ auto_bind_card.py
              ├─ account_manager.py
              ├─ database.py
              ├─ sheerid_verifier.py
              └─ sheerid_gui.py
```

核心约定：
- “环境/浏览器 Profile”的稳定 key 使用 `email`：profile name = email。
- `GeekProcess.ensure_profiles()` 负责把 `accounts.txt` 映射成 GeekezBrowser profiles。

---

## 3. GeekezBrowser 侧约定

### 3.1 控制端口

默认在 `2dev/geek/geek_main_gui.py`：
- `CONTROL_HOST = 127.0.0.1`
- `CONTROL_PORT = 19527`

控制端口由 GeekezBrowser（外部仓库）在启动参数 `--control-port=19527` 时提供。

### 3.2 profiles/settings 文件位置

在 `2dev/geek/geek_browser_api.py` 的 `_default_data_dir()`：
- Windows：`%APPDATA%\geekez-browser\BrowserProfiles`
- 非 Windows fallback：`~/.config/geekez-browser/BrowserProfiles`

文件：
- `profiles.json`：profile 列表（本项目会在此 upsert profile）
- `settings.json`：会写入 `enableRemoteDebugging=true`（用于 Playwright CDP 连接）

---

## 4. P工具箱 GUI 的任务入口与 task_type

文件：`2dev/geek/geek_main_gui.py`

### 4.1 顶部引擎开关

- `toggle_engine(checked=True)` → `start_task("start_app")`
  - 调用 `AppLauncher.start()`（内部通过 `npm start -- --control-port=...` 启动 GeekezBrowser）
- `toggle_engine(checked=False)` → `AppLauncher.stop()`
  - 优先走 `POST /shutdown` 优雅退出，再 best-effort terminate 进程，并等待 `/health` 下线

### 4.2 工具箱：Google 专区

- `SheerLink 获取` → `start_task("sheerlink")`
  - `GeekProcess.run_sheerlink()`
- `仅绑卡 (无API)` → `start_task("bind")`
  - 代码复用的是 `GeekProcess.run_auto()`，但会传 `api_key=""`（即只做：登录/检测/若已 verified 则绑卡；若 link_ready 则仅保存链接）
- `全自动 (验证+绑卡)` → `start_task("auto")`
  - `GeekProcess.run_auto()`（如果提供 API Key 则走 verify_single）
- `SheerID 批量验证` → `action_open_sheerid_window()`
  - 直接打开 `sheerid_gui.SheerIDWindow`（读取 `sheerIDlink.txt` 进行批量验证）

### 4.3 工具箱：数据管理

- `环境创建/更新` → `start_task("ensure_profiles")`
  - `GeekProcess.ensure_profiles()`
- `账号编辑/代理编辑/卡号编辑`
  - `DataEditorDialog` 直接编辑根目录的：`accounts.txt` / `proxies.txt` / `cards.txt`

### 4.4 表格区域

- 行内按钮 `▶️/⏹️`：分别 `start_task("launch", [email])`、`start_task("close", [email])`
- 批量按钮 `▶️ 批量启动/⏹️ 批量关闭`：分别 `start_task("launch")`、`start_task("close")`

---

## 5. GeekProcess 与原仓库模块依赖（关键点）

文件：`2dev/geek/geek_process.py`

### 5.1 复用的原仓库能力（直接 import）

- `auto_bind_card.py`
  - `check_and_login(page, account_info)`：用于登录
  - `auto_bind_card(page, card, account_info)`：用于绑卡/订阅

- `account_manager.py`
  - `AccountManager.save_link(line)`：写 `sheerIDlink.txt`
  - `AccountManager.move_to_verified(line)`：写 `已验证未绑卡.txt`
  - `AccountManager.move_to_ineligible(line)`：写 `无资格号.txt`
  - `AccountManager.move_to_subscribed(line)`：写 `已绑卡号.txt`
  - `AccountManager.move_to_error(line)`：写 `超时或其他错误.txt`

- `database.py`
  - `DBManager.update_status(email, status, message=...)`：更新 SQLite 作为单一数据源

- `sheerid_verifier.py`
  - `SheerIDVerifier.verify_single(link)`：单个链接验证（`run_auto()` 中使用）
  - `SheerIDVerifier.verify_batch(...)`：批量验证（主要在 `sheerid_gui.py` 中使用）

- `sheerid_gui.py`
  - `SheerIDWindow`：现成的批量验证窗口

### 5.2 GeekProcess 自己做的事（适配层）

- 解析数据文件：
  - `load_accounts()`：读取根目录 `accounts.txt`（支持第一行 `分隔符=`）
  - `load_proxies()`：读取 `proxies.txt`（支持 `http://` / `socks5://` / `host:port`）
  - `load_cards()`：读取 `cards.txt`（空格分隔：number exp_month exp_year cvv）

- Geek 环境映射：
  - `ensure_profile()` / `ensure_profiles()`：profile name = email，metadata.remark 保存账号行信息
  - `launch_by_email()` / `close_by_email()`：通过 `GeekezBrowserAPI` 调起控制端口

- Playwright 连接：
  - `_connect_page(cdp_endpoint)`：`playwright.chromium.connect_over_cdp()`
  - 通过 `LaunchInfo.cdp_endpoint`（通常是 `http://127.0.0.1:{debugPort}`）连接

---

## 6. 可复用模块清单（按复用成本分类）

这一节用于回答：“以后加新专区（例如 GB 专区）时，哪些东西可以直接复用？”

### 6.1 可直接复用（建议优先复用）

- `2dev/geek/geek_browser_api.py`
  - `GeekezBrowserAPI`：控制端口 + profiles/settings 文件读写
  - `LaunchInfo`：统一承载 debugPort/cdpEndpoint

- `2dev/geek/geek_process.py`
  - `load_accounts/load_proxies/load_cards`
  - `proxy_to_url()`
  - `ensure_profiles()/launch_by_email()/close_by_email()`
  - `_connect_page()`：统一 Playwright CDP 接入

- `account_manager.py`
  - 账号状态输出文件的“落盘规范”已经稳定（有资格/已验证/已绑卡/无资格/错误等）

- `database.py`
  - `DBManager.update_status()` 等状态维护接口（把 SQLite 当单一数据源）

- `sheerid_verifier.py`
  - `SheerIDVerifier.verify_single()` 适合用于“单账号自动流程”

### 6.2 需要薄封装后复用（建议：专区内封装调用）

- `auto_bind_card.py`
  - 页面操作偏“Google One AI Student 业务专用”。
  - 但它已经沉淀了大量 iframe/支付表单兼容逻辑。
  - 若新专区的付款/支付流程相似（同属 Google Payments），可以薄封装复用；否则不建议硬套。

- `2dev/email_verifier.py`
  - `EmailVerifier` 是 IMAP 读取验证码的通用组件。
  - 但它当前的“筛选规则”偏 Google 邮件（发件人/主题关键字），新专区可能需要扩展 `_is_google_verification_email()`。

- `2dev/geek/geek_main_gui.py`
  - `GeekWorkerThread` 的 stdout/stderr 捕获对“复用旧模块大量 print() 输出”很有价值。
  - 如果新专区也会复用旧脚本，建议沿用此日志捕获方式。

### 6.3 不建议复用（仅当作参考/样例）

- `2dev/geek/geek_template.py`
  - 更像 demo：展示 Drission/Playwright/CDP 三种连接方式，适合参考，不要直接依赖。

- `2dev/geek/auto-goo-login.py`
  - 是历史脚本：偏人工交互/暂停输入，不符合当前 GUI 并发模型。

---

## 7. 新增一个专区（GB/GPT）推荐做法

原则：
- 新专区的业务逻辑放在“流程层”（优先 `2dev/geek/geek_process.py`，或在 `2dev/<zone>/` 新建模块然后由 `GeekProcess` 调用）。
- GUI 只新增按钮 + `task_type`；不要在 GUI 里写 Playwright 具体页面逻辑。

下面给一个最小模板（推荐沿用现有模式）。

### 7.1 在流程层新增一个入口方法

建议：在 `2dev/geek/geek_process.py` 增加 `run_gb_xxx()`（命名按专区前缀区分）。

```python
# 伪代码示例：放在 2dev/geek/geek_process.py

def run_gb_xxx(
    self,
    account: Dict[str, Any],
    proxy_str: Optional[str] = None,
    log_callback: Optional[Callable[[str], None]] = None,
) -> Tuple[bool, str]:
    email = (account.get("email") or "").strip()
    if not email:
        return False, "missing email"

    self.ensure_profile(account, proxy_str=proxy_str)
    launch = self.launch_by_email(email)

    async def _runner() -> Tuple[bool, str]:
        playwright = None
        try:
            playwright, browser, page = await self._connect_page(launch.cdp_endpoint)
            # 1) page.goto(...) 进入专区目标页面
            # 2) 复用/调用该专区的自动化逻辑
            # 3) 更新 AccountManager / DBManager 状态
            return True, "ok"
        finally:
            if playwright:
                try:
                    await playwright.stop()
                except Exception:
                    pass

    try:
        ok, msg = asyncio.run(_runner())
        return ok, msg
    finally:
        self.close_by_profile_id(launch.profile_id)
```

落库/落盘建议：
- 只要有“可解释的状态”，就用 `DBManager.update_status()` 写入数据库。
- 同时使用 `AccountManager.move_to_xxx()` 维持现有的 txt 输出规范（便于人工查看和与旧链路兼容）。

### 7.2 在 GUI 左侧工具箱新增专区入口

在 `2dev/geek/geek_main_gui.py`：
- 仿照 `_add_google_section()` 新增 `_add_gb_section()`
- 新按钮直接绑定 `self.start_task("gb_xxx")`

（注意：GUI 改动应只做入口和参数采集，不要把业务逻辑写进来。）

### 7.3 在 GeekWorkerThread 中增加 task_type 分支

在 `2dev/geek/geek_main_gui.py` 的 `GeekWorkerThread.run()`：

```python
if self.task_type == "gb_xxx":
    # 取账号/代理等数据
    ok, msg = proc.run_gb_xxx(acc, proxy_str=proxy_str, log_callback=log_cb)
    return email, ok, msg
```

并发规则：
- 复用现有 `ThreadPoolExecutor` 并发模型即可。
- 需要序列化资源（例如同一张卡不能并发）时，在流程层做锁/队列。

### 7.4 最小化输出约定（新专区也要写清楚）

建议每个新 task 都写一个“小契约”，至少包含：
- 输入：用到哪些文件/字段（accounts/proxies/cards/api key）
- 输出：会写哪些 DB/status；会写哪些 txt
- 成功/失败判定：返回值含义（`(ok: bool, msg: str)`）

---

## 8. 常见坑

- 控制端口不通：先用 `GET /health` 确认 GeekezBrowser 是否用 `--control-port` 启动。
- Playwright 连接失败：确认 `settings.json` 的 `enableRemoteDebugging=true`；以及 `/profiles/{id}/launch` 返回的 `debugPort/wsEndpoint` 是否正确。
- 日志看不到：GUI 的 stdout/stderr capture 是在 worker thread 内完成的，业务逻辑如果开了新线程，需要注意线程上下文（当前实现用 thread-local email 标注日志）。
