# 统一浏览器池化与自动化运行时（Geekez / BitBrowser）

目标：让所有自动化任务只关注业务逻辑（注册、邀请、绑卡、2FA…），浏览器的“创建 / 启动 / 连接 / 释放 / 复用”全部由统一的基础设施负责。

适用范围：后续所有专区、所有自动化 Celery 任务。

---

## 为什么必须统一

1) Celery 运行在 Docker/容器里时，本地 `chrome` 往往不存在或不可用；而 Geekez/BitBrowser 本质是“远程浏览器环境”。

2) 需要在任务间复用浏览器 profile（减少频繁创建/启动的开销），同时要可控并发（避免多个任务抢同一个 profile）。

3) 不希望业务代码里出现：
- create_profile / launch_profile / connect_over_cdp
- 连接断开重试
- close_profile / 资源回收

业务代码应该只做：拿到 `page` → 跑业务步骤 → 出错截图/日志。

---

## 现有实现（代码位置）

### 1) 统一浏览器适配层

文件：`backend/apps/integrations/browser_base.py`

核心概念：
- `BrowserType`：`GEEKEZ` / `BITBROWSER`
- `get_browser_manager()`：获取浏览器管理器
- `BrowserManager.get_api(browser_type)`：返回统一 API（create_or_update_profile / launch_profile / close_profile）

说明：
- 默认会优先选择 Geekez（如果可用）。

### 2) 浏览器池（Pool）

文件：`backend/apps/integrations/browser_pool.py`

能力：
- `BrowserPool.acquire_by_profile_name(...)`：
  - create/update profile
  - launch profile
  - 获取 `ws_endpoint`/`cdp_endpoint`
  - Playwright `connect_over_cdp()` 连接
  - 建立可复用的 `BrowserSession`

- `BrowserPool.release(browser_id, close=False)`：释放 session（默认不关闭，用于复用）

- 自动处理：
  - busy/idle 标记（防止多任务抢同一 profile）
  - 简单过期清理（长时间不使用可关闭）

注意：
- Pool 是“进程内池化”（每个 Celery worker 进程各自维护一份）。
- 如果你开了多个 Celery worker 实例，每个实例都有自己的 Pool，这是预期行为。

### 3) 业务侧运行时封装（推荐入口）

文件：`backend/plugins/gpt_business/services/geekez_runtime.py`

提供：
- `acquire_geekez_page(...)`：一个 async context manager
  - 内部自动从 Pool 获取 session
  - 每次任务创建一个全新的 `Page`（避免上下文污染）
  - finally 自动 close page + release 回池

这个入口是我们希望后续所有插件/任务都复用的模板。

---

## 业务代码怎么写（标准模板）

原则：
- 业务代码不关心 profile 启动/连接细节
- 业务代码只处理 `page` 操作

示例（伪代码）：

```python
from apps.integrations.browser_base import BrowserType
from plugins.gpt_business.services.geekez_runtime import acquire_geekez_page

async def run_business_flow(*, record_id: str, profile_name: str, proxy_str: str | None):
    meta = {
        "zone": "your_zone",
        "account": {"id": "...", "email": "..."},
    }

    async with acquire_geekez_page(
        profile_name=profile_name,
        task_id=record_id,
        proxy=proxy_str,
        metadata=meta,
        browser_type=BrowserType.GEEKEZ,
        timeout_ms=60_000,
        wait_seconds=30,
    ) as (page, profile_id):
        # 下面开始只写业务步骤
        await page.goto("https://example.com", wait_until="domcontentloaded")
        # ...
        return {"profile_id": profile_id}
```

---

## 并发与复用规则（必须遵守）

1) 同一个 profile 同一时间只能被一个任务占用。
   - Pool 会用 `is_busy` 阻止并发抢占。

2) 不要在业务代码里调用 `close_profile()`。
   - 释放/关闭由 Pool 统一管理。

3) 每个任务建议用 `context.new_page()` 创建新页面。
   - 这样可以复用同一个浏览器进程，但隔离页面状态。

4) 任务结束必须 release。
   - 必须使用 context manager（`acquire_geekez_page`）来确保 finally 执行。

---

## Proxy 约定

统一使用 `scheme://user:pass@host:port` 字符串形式（Geekez adapter 也支持）。

如果你拿到的是 dict（host/port/username/password/type），请在业务层转换成字符串后传入 Pool。

---

## 日志与产物（建议做法）

所有自动化任务必须产出：
- `run.log`：关键步骤日志（每步写一行）
- 失败截图：`*_failed.png`

后端任务下载能力：
- `GET /api/v1/plugins/<zone>/tasks/{id}/artifacts/`
- `GET /api/v1/plugins/<zone>/tasks/{id}/download/{filename}/`

前端：任务列表中提供“查看产物/下载 run.log”。

---

## 常见问题（排错）

1) 启动任务没反应
- 看 task 是否进入 running
- 下载 `run.log` / 失败截图

2) 连接不上 Geekez
- 确认 `/admin/geekez` 已配置并启用
- Geekez 服务健康检查通过

3) Pool 拿不到 session（一直 busy）
- 说明同 profile 有任务未 release（或任务卡死）
- 临时方案：force_new 或换 profile_name

---

## 后续演进（可选）

如果未来需要“跨进程/跨实例共享池”，需要引入：
- Redis 分布式锁（按 profile_id 加锁）
- 全局 session registry

当前版本的设计目标是：先把自动化链路打通，并在单 worker 内实现稳定复用。
